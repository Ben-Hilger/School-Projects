/**   A class that implements the ADT deque by using a doubly linked chain of nodes.      @author Frank M. Carrano   @author Timothy M. Henry   @version 4.0*/public class LinkedDeque<T> implements DequeInterface<T>{   private DLNode lastNode;  // References node at back of deque		public LinkedDeque()	{		lastNode = null; // Creates an empty deque	} // end default constructor		public void clear()	{		lastNode = null; // Sets the last node to null, clearing the list	} // end clear	public void addToBack(T newEntry)	{		DLNode newNode = new DLNode(lastNode, newEntry, null);				if(isEmpty()) {			newNode.setNextNode(newNode); // Wraps around itself since it's the only node			newNode.setPrevNode(newNode); // Wraps around itself since it's the only node		} else {						lastNode.getNext().setPrevNode(newNode); // Gets the top node and sets its previous to the new node			newNode.setNextNode(lastNode.getNext()); // Sets the prev of the top node to the new node			lastNode.setNextNode(newNode);					}				lastNode = newNode; // Sets the last node to the new node	} // end addToBack	public void addToFront(T newEntry)	{		DLNode newNode = new DLNode(lastNode, newEntry, null);				if(isEmpty()) {			newNode.setNextNode(newNode);			newNode.setPrevNode(newNode);			lastNode = newNode;		} else {			newNode.setNextNode(lastNode.getNext());			lastNode.getNext().setPrevNode(newNode);			lastNode.setNextNode(newNode);		}	} // end addToFront   	public T getBack()	{		if(isEmpty()) {			throw new EmptyQueueException();		}				return lastNode.getData();	} // end getBack   	public T getFront()	{		if(isEmpty()) {			throw new EmptyQueueException();		}				return lastNode.getNext().getData();	} // end getFront	public T removeFront()	{				// Checks if the deque is empty		if(isEmpty()) {			throw new EmptyQueueException(); // Since it's empty, throw and error to the user			}				DLNode front = lastNode.getNext();				// Checks if there was only one item in the deque		if(front == lastNode) {			lastNode = null; // Sets lastNode to null		} else {			lastNode.setNextNode(front.getNext()); // Sets the next reference to the node after the front node			front.getNext().setPrevNode(lastNode); // Sets the prev reference for the new head to the last node		}				return front.getData(); // Returns the data of the removed item to the user			} // end removeFront			public T removeBack()	{		// Checks if the deque is empty		if(isEmpty()) {			throw new EmptyQueueException(); // Since it's empty, throw and error to the user			}				// Checks if the last node is the only one in the deque		if(lastNode.getNext() == lastNode) {			DLNode oldLast = lastNode; // Stores the node being removed in a temporary variable			lastNode = null; // Removes the reference to the node being removed						return oldLast.getData(); // Returns the data removed to the user		} else {			DLNode newBack = lastNode.getPrevious(); // Gets the node before the last node			DLNode frontNode = lastNode.getNext(); // Gets the node at the front of the deque									newBack.setNextNode(frontNode); // Sets the next of the node to the front, breaking the relationship with the node being removed			frontNode.setPrevNode(newBack); // Sets the prev of the front node to the new back, breaking the relationship with the node being removed						DLNode oldLast = lastNode; // Stores the old last node in a temporary variable			lastNode = newBack; // Updates the lastNode to the new reference, removing all pointers to the old lastNode				return oldLast.getData(); // Returns the data removed to the user					}			} // end removeBack	public boolean isEmpty()	{		return lastNode == null;	} // end isEmpty		/**	* 	* The string is formed using the data from the front to the back of the deque.	* If a deque has the following data: Front-> Ava, Joe, Sarah, Robert <-Back then	* the toString should return a string "[Ava, Joe, Sarah, Robert]"	* It returns "[]" for an empty deque	* @return a string representing the content of the deque from the front to the back.	*/ 		public String toString(){				// Checks if the deque is empty		if(isEmpty()) {			return "[]"; // Since the deque is empty, it returns the default string		} else {						String toStr = "["; // Stores the value to be returned, starts with an open bracket			DLNode current = lastNode.getNext(); // Gets the front node in the list to start exploring the deque						// Explores the node list until it reaches the last node			while(current != lastNode) {								toStr += current.getData() + ", "; // Adds the data to the toString				current = current.getNext(); // Gets the next node in the deque						}						toStr += lastNode.getData() + "]"; // Adds the last node to the data and the closing bracket						return toStr; // Returns the string to the user		}			}		private class DLNode	{		private T      data;  	 // Deque entry		private DLNode next;  	 // Link to next node		private DLNode previous; // Link to previous node		private DLNode(T data)		{			this.data = data;			next = null;				previous = null;			} // end constructor				private DLNode(DLNode previousNode, T data, DLNode nextNode)		{			this.data = data;			next = nextNode;				previous = previousNode;		} // end constructor				// You can add getters and setters for the other two references		public void setNextNode(DLNode newNode) {			next = newNode;		} // end setNextNode				public void setPrevNode(DLNode newNode) {			previous = newNode;		}				public DLNode getPrevious() {			return previous;		}				public DLNode getNext() {			return next;		}				public T getData() {			return data;		}			} // end DLNode} // end LinkedDeque