/**   A class that implements the ADT queue by using an expandable   circular array.   @author Frank M. Carrano   @author Timothy M. Henry   @author Joseph Erickson   @version 4.0 */public final class ArrayQueue<T> implements QueueInterface<T>{	// To Do: Declare instance variables	private int frontIndex = 0;	private  int backIndex = -1;	private T[] queue; 				private static final int DEFAULT_CAPACITY = 3; // Small capacity for testing	private static final int MAX_CAPACITY = 10000;	public ArrayQueue()	{		this(DEFAULT_CAPACITY);	} // end default constructor	@SuppressWarnings("unchecked")	public ArrayQueue(int initialCapacity)	{		checkCapacity(initialCapacity); // Ensures the capacity is within the allowed range		queue = (T[]) new Object[initialCapacity]; // Initializes a new empty array with the specified size, and ensures that only the max allowed space is used	} // end constructor	public void enqueue(T newEntry)	{		checkInitialization(); // Checks to make sure the queue is initialized		ensureCapacity(); // Ensures there is enough space to add the new entry		backIndex++; // Increases the back index to represent the new entry		queue[backIndex] = newEntry; // Adds the new entry to the back of the queue			} // end enqueue	public T getFront()	{		checkInitialization(); // Checks to make sure the queue is initialized				// Checks if the queue is empty		if(isEmpty()) {			throw new EmptyQueueException(); // Reports an exception to the user		} else {			return queue[frontIndex % queue.length]; // Returns the item in the front of the queue		}	} // end getFront	public T dequeue()	{		checkInitialization(); // Checks to make sure the queue is initialized				// Checks if the queue is empty		if(isEmpty()) {			throw new EmptyQueueException(); // Reports an exception to the user		} else {			T front = getFront(); // Gets the front data in the queue			queue[frontIndex % queue.length] = null; // Removes the data from the front			frontIndex++; // Increments frontIndex to reflect the removal of the front item						//Checks if the queue is now empty			if(isEmpty()) {				frontIndex = 0; // Sets frontIndex to its default value 0				backIndex = -1; // Sets backIndex to its default value -1			}						return front; // Returns the data in the front of the queue		}			} // end dequeue	public boolean isEmpty()	{		return backIndex < frontIndex; // Returns true if the frontindex is greater than the back index, false otherwise	} // end isEmpty	@SuppressWarnings("unchecked")	public void clear()	{		frontIndex = 0; // Sets frontIndex to its default value		backIndex = -1; // Sets backIndex to its default value		queue = (T[]) new Object[queue.length]; // Reinitializes the queue to empty, keeping its size		}// end clear	// Throws an exception if this object is not initialized.	private void checkInitialization() 	{		// Checks if the queue object is equal to zero		if(queue == null) {			throw new RuntimeException("Queue was not initialized correctly"); // Reports an error to the user		}	} // end checkInitialization	// Throws an exception if the client requests a capacity that is too large.	private void checkCapacity(int capacity)	{		if(capacity > MAX_CAPACITY) {			throw new RuntimeException("Desired size is greater than allowed");		}			} // end checkCapacity	// Doubles the size of the array queue if it is full.	// Precondition: checkInitialization has been called.	private void ensureCapacity()	{		// Checks if the queue is full		if(backIndex - frontIndex + 1 == queue.length) {			T[] oldQueue = queue; // Stores the queue in a temporary variable			int oldSize = queue.length; // Stores the size of the queue in a temporary variable			int newSize = oldSize * 2; // Stores the new size in a temporary variable			checkCapacity(newSize); // Ensures the new size is within the allowed size						@SuppressWarnings("unchecked")			T[] tempQueue = (T[]) new Object[newSize]; // Creates a new queue with the new size			queue = tempQueue; // Sets the queue object to the new queue						// Runs through all data of the old queue and puts it in the new queue			for(int index = 0; index < oldSize; index++) {				queue[index] = oldQueue[frontIndex % oldSize]; // Adds the data from the old queue to the new queue, keeping order				frontIndex++; // Increases front index by 1			}			frontIndex = 0; // Sets front index to 0			backIndex = oldSize-1; // Sets back index to the oldSize-1		}			} // end ensureCapacity}  // end ArrayQueue