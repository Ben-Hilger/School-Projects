#ifndef MATRIX_H
#define MATRIX_H

/** \file matrix.h A 2-D matrix class.  This file contains the
    declaration for a simple 2-D matrix class along with several
    convenience operators to streamline its use.

    Copyright (C) 2021 Ben Hilger
*/

#include <iostream>
#include <functional>
#include <vector>
#include <cassert>

/** Shortcut for the value of each element in the matrix */
using Val = double;

/** Short cut to a 2-d vector double values to streamline the code */
using TwoDVec = std::vector<Val>;

/** A matrix class to perform basic matrix operations.

    The class essentially encapsulates a 2-d matrix of double values
    and performs the following matrix operations:

    <ul>
    <li>Create a matrix of given dimensions.</li>

    <li>Matrix multiplication using Block matrix multiplication.</li>

    <li> Stream insertion and extraction operators to conveniently
    load and print values.</li>
    
    </ul>
*/
class Matrix : public TwoDVec {
    /** Stream insertion operator to ease printing matrices
     *
     * This method prints the dimension of the matrix and then prints
     * the values in a row-by-row manner.  The output is setup to be
     * consistent with the stream extraction operator.
     *
     * \param[out] os The output stream to where the data is to be
     * written. This could be any output stream -- for example,
     * a std::ofstream, std::ostringstream, or std::cout.
     *
     * \param[in] matrix The matrix to be written.
     *
     * \return As per convention, this method returns the supplied
     * output stream.
     */
    friend std::ostream& operator<<(std::ostream& os, const Matrix& matrix);

    /** Stream extraction operator to ease reading matrices
     *
     * This method reads the dimension of the matrix and then reads
     * the values in a row-by-row manner.  The input is assumed to be
     * that one generated by the stream insertion operator.
     *
     * \param[in/out] in The input stream to where the data is to be
     * read. This could be any input stream -- for example,
     * a std::ifstream, std::istringstream, or std::cin.
     *
     * \param[in] matrix The matrix to be read.
     *
     * \return As per convention, this method returns the supplied
     * input stream.
     */
    friend std::istream& operator>>(std::istream& is, Matrix& matrix);

    size_t rows;
    size_t cols;

    /**
     * Converts the given row and column values into the corresponding
     * index that will be used in getting the value from the main vector 
     * 
     * \param[in] row The request row of the Matrix
     * \param[in] col The requested column of the Matrix
     * 
     * \return An index that represents the location of the request value
     * in the main vector
     */
    size_t getIndex(size_t row, size_t col) const {
        // Return the converted values
        return row * cols + col;
    }

public:
    /**
     * Constructor to create and initialize a matrix.
     *
     * \param[in] rows The number of rows to be created in the
     * matrix.
     *
     * \param[in] cols The number of cols to be created in the matrix.
     *
     * \param[in] initVal The inital value to be set for each entry in
     * the matrix.
     */
    explicit Matrix(const size_t rows = 0, const size_t cols = 0,
                    const Val initVal = 0);

    /**
     * Returns the height or number of rows in this matrix.
     *
     * \return Returns the height or number of rows in this matrix.
     */
    size_t height() const { return rows; }  
    // size(); }

    /**
     * Returns the width or number of columns in this matrix.
     *
     * \return Returns the width or number of columns in this matrix.
     */
    size_t width() const { return cols; }  
    // (height() > 0) ? front().size() : 0; }
    
    /**
     * Creates a new matrix in which each value is obtained by
     * applying a given unary operator to each entry in the matrix.
     *
     * \param[in] operation The unary operation to be used to create
     * the given matrix.
     */
    template<typename UnaryOp>
    Matrix apply(const UnaryOp& operation) const {
        // If the matrix is empty, then we have nothing to do.
        if (empty()) {
            return *this;  // return copy of empty matrix.
        }
        // Now apply the specified operation to each element and store it
        // in the new matrix
        Matrix result = *this;  // Initialize to current values.
        // Apply unary operation to each element in the result
        for (size_t row = 0; row < rows; row++) {
            for (size_t col = 0; col < cols; col++) {
                operation(result.get(row, col));
            }
        }
        // The resulting matrix after applying specified operations.
        return result;
    }

    /**
     * Creates a new matrix in which each value is obtained by
     * applying a given binary operator to each entry in this matrix
     * and another matrix.
     *
     * \param[in] other The other matrix to be used. Note that the
     * other matrix must be exactly the same dimension of this this.
     * Otherwise, this method throws an exception.
     *
     * \param[in] operation The binary operation to be used to create
     * each value in the given matrix.
     */    
    template<typename BinaryOp>
    Matrix apply(const Matrix& other, const BinaryOp& operation) const {
        // Check to ensure the number of rows are the same.
        assert(height() == other.height());
        // If the matrix is empty, then we have nothing to do.
        if (empty()) {
            return *this;  // return copy of empty matrix.
        }
        // Ensure the number of columns match.
        assert(width() == other.width());
        // Now apply the specified operation to each element and store it
        // in the new matrix
        Matrix result = *this;  // Initialize to current values.
        // Here we use index so that we can access the corresponding
        // element in the other matrix as well.
        for (size_t row = 0; (row < height()); ++row) {
            for (size_t col = 0; (col < width()); ++col) {
                // Recollect result is initialized to values of this
                // matrix. So we use result to reduce the number of
                // different values accessed.
                result.set(row, col, operation(result.get(row, col),
                                            other.get(row, col)));
            }
        }
        // The resulting matrix after applying specified operations.
        return result;
    }

    /**
     * Operator to add two matrices with the same dimensions together.
     *
     * \param[in] rhs The other matrix to be used.  This matrix must
     * have the same dimension as this matrix.  Otherwise this method
     * throws an excpetion.
     *
     * \return The resulting matrix in which each value has been
     * computed by adding the corresponding values from \c this and
     * rhs.
     */
    Matrix operator+(const Matrix& rhs) const {
        return apply(rhs, [](const auto& v1, const auto& v2) {
                              return v1 + v2; });
    }

    /**
     * Operator for computing the Hadamard product of two matrices
     * with the same dimensions.
     *
     * \param[in] rhs The other matrix to be used.  This matrix must
     * have the same dimension as this matrix.  Otherwise this method
     * throws an excpetion.
     *
     * \return The resulting matrix in which each value has been
     * computed by multiplying the corresponding values from \c this
     * and rhs.
     */
    Matrix operator*(const Matrix& rhs) const {
        return apply(rhs, [](const auto& v1, const auto& v2) {
                              return v1 * v2; });
    }

    /**
     * Operator for computing the Hadamard product of two matrices
     * with the same dimensions.
     *
     * \param[in] rhs The other matrix to be used.  This matrix must
     * have the same dimension as this matrix.  Otherwise this method
     * throws an excpetion.
     *
     * \return The resulting matrix in which each value has been
     * computed by multiplying the corresponding values from \c this
     * and rhs.
     */
    Matrix operator*(const Val val) const {
        return apply([val](const auto& v) { return v * val; });
    }
    
    /**
     * Operator to subtract two matrices with the same dimensions.
     *
     * \param[in] rhs The other matrix to be used.  This matrix must
     * have the same dimension as this matrix.  Otherwise this method
     * throws an excpetion.
     *
     * \return The resulting matrix in which each value has been
     * computed by subtracting the corresponding values from \c this
     * and rhs.
     */
    Matrix operator-(const Matrix& rhs) const {
        return apply(rhs, [](const auto& v1, const auto& v2)  {
                              return v1 - v2; });
    }
    
    /**
     * Subtracts the given matrix with the same dimensions inline.
     *
     * \param[in] rhs The other matrix to be used.  This matrix must
     * have the same dimension as this matrix.  Otherwise this method
     * throws an excpetion.
     */
    void subtract(const Matrix& rhs) {
        for (size_t row = 0; (row < height()); ++row) {
            for (size_t col = 0; (col < (*this).width()); ++col) {
                // Subtract the value from the current matrix
                (*this)[getIndex(row, col)] -= rhs[rhs.getIndex(row, col)];
            }
        }
    }

    /**
     * Adds the given matrix with the same dimensions inline.
     *
     * \param[in] rhs The other matrix to be used.  This matrix must
     * have the same dimension as this matrix.  Otherwise this method
     * throws an excpetion.
     */
    void add(const Matrix& rhs) {
        for (size_t row = 0; (row < height()); ++row) {
            for (size_t col = 0; (col < (*this).width()); ++col) {
                // Add the value from the current matrix
                (*this)[getIndex(row, col)] += rhs[rhs.getIndex(row, col)];
            }
        }
    }

    /**
     * Multiplies the given matrix with the same dimensions inline.
     *
     * \param[in] rhs The other matrix to be used.  This matrix must
     * have the same dimension as this matrix.  Otherwise this method
     * throws an excpetion.
     */
    void multi(const Matrix& rhs) {
        for (size_t row = 0; (row < height()); ++row) {
            for (size_t col = 0; (col < (*this).width()); ++col) {
                // Mulyiply the matrix value
                (*this)[getIndex(row, col)] *= rhs[rhs.getIndex(row, col)];
            }
        }
    }

    /**
     * Multiples the given val with the same dimensions inline.
     *
     * \param[in] val The value to multiply each compartment by
     * 
     * \return Itself for convience
     */
    Matrix multi(const Val val) {
        for (size_t row = 0; (row < height()); ++row) {
            for (size_t col = 0; (col < (*this).width()); ++col) {
                // Multiply the current value by val
                (*this)[getIndex(row, col)] *= val;
            }
        }
        return (*this);
    }

    /**
     * Performs the dot product of two matrices. This method has a
     * O(n^3) time complexity.
     *
     * \param[in] rhs The other matrix to be used.  This matrix must
     * have the same number of rows as the number of columns in this
     * matrix.  Otherwise this method throws an excpetion.
     *
     * \return The resulting matrix in which each value has been
     * computed by multiplying the corresponding values from \c this
     * and rhs.
     */
    Matrix dot(const Matrix& rhs, Matrix& result);

    /**
     * Returns the transpose of this matrix.
     */
    Matrix transpose(Matrix& result);
    
    /**
     * Checks if the given Matrix will need to be resized in order to 
     * fit the specified number of rows and columns
     * 
     * @note If the current matrix is larger than the given row and 
     * column size, then the Matrix won't need to be resized
     * 
     * \param[in] rows The number of rows needed in the new array
     * \param[in] cols The number of columns needed in the new array
     * 
     * \return true if the Matrix would need to be resized to fit the
     * given dimension, false otherwise
     */
    bool needsResized(size_t rows, size_t cols) {
        // Return if the given rows is greater than the current
        // height of the matrix, or if the given number of columns is 
        // greater than the current width of the matrix
        return height() < rows || width() < cols;
    }

    /**
     * Resizes the Matrix to the given rows.
     * 
     * @note Will automatically check and resize the main vector if necessary
     * but will only resize the vector if the matrix is too small to fit
     * the new dimension. If the matrix is larger, it will keep the larger
     * footprint.
     * 
     * \param[in] rows The number of rows needed in the resized matrix
     * \param[in] cols The number of columns needed in the resized matrix
     * 
     */
    void resizeMatrix(size_t rows, size_t cols) {
        // Check if the matrix needs to be resized in order to fit 
        // the new dimensions
        if (needsResized(rows, cols)) {
            // Resize to fit the new dimensions
            this->resize(rows * cols);
        }
        // Set the number of rows and columns to the given number
        // of rows and number of columns
        this->rows = rows;
        this->cols = cols;
    }

    /**
     * Gets the value stored at the given row and column
     * 
     * \param[in] row The row that stores the request value
     * \param[in] col The column that the request value is stored
     * 
     * \return The Val found at the given row and column location in the
     * Matrix
     */
    Val get(size_t row, size_t col) const {
        // Get the index of the value in the main vector 
        size_t index = getIndex(row, col);
        // Return the value at the given index
        return (*this)[index];
    }

    /**
     * Sets the given location in the Matrix to the value specified
     * 
     * \param[in] row The row that will store the given value
     * \param[in] col The column that will store the given value
     * \param[in] val The value to set at the specified location in the Matrix
     */
    void set(size_t row, size_t col, Val val) {
        // Get the index of the value in the main vector 
        size_t index = getIndex(row, col);
        // Set the location to the given value
        (*this)[index] = val;
    }

    /**
     * Gets all of the values of the request row. 
     * 
     * \param[in] row The row to get all of the values 
     * 
     * \return A vector containing all of the values in the order they
     * appear on the Matrix
     */
    std::vector<Val> getRow(size_t row) {
        // Store the values of the given
        std::vector<Val> rowVals;
        // Iterate through the main vector
        for (size_t i = 0; i < cols; i++) {
            // Add the next value to the vector
            rowVals.push_back((*this)[row * rows + i]);
        }
        // Return the vector containing the values
        return rowVals;
    }
};


#endif
